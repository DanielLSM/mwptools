#!/usr/bin/ruby

#require 'ap'

require 'serialport'
require 'optparse'

class MSP

  HDR="$M<"
  DEV='/dev/ttyUSB0'

  S_END=0
  S_HEADER=1
  S_SIZE=2
  S_CMD=3
  S_DATA=4
  S_CHECKSUM=5
  S_ERROR=6
  S_HEADERA=7
  S_HEADERB=8

  IDENT=100
  SERVO_CONF=120
  SET_SERVO_CONF=212
  EEPROM_WRITE=250

  def cksum(s,init=0)
    ck=init
    s.each_byte do |c|
    ck ^= c
    end
    ck
  end

  def read_data
    data_to_read=1
    state=S_HEADER
    checksum=0
    ok=false
    data_raw=''
    data_size=0
    cmd=nil
    tout = 0

    while (state!=S_END) and (state!=S_ERROR) do
      c=@fd.sysread(data_to_read)
      if c.nil?
	tout += 1
	puts "Timeout"
      end
      case state
      when S_HEADER
	if c == '$'
	  state = S_HEADERA
	else
	  puts "Error in header"
	  state=S_ERROR
	end
      when S_HEADERA
	if c=='M'
	  state = S_HEADERB
	else
	  puts "Error in header"
	  state=S_ERROR
	end
      when S_HEADERB
	if c=='!' or c == '>'
	  state = S_SIZE
	else
	  puts "Error in header"
	  state=S_ERROR
	end
      when S_SIZE
	data_size=c.ord
	checksum ^= data_size
	state=S_CMD
      when S_CMD
	cmd=c.ord
	checksum ^= cmd
	if data_size == 0
	  data_to_read=1
	  state=S_CHECKSUM
	else
	  data_to_read = data_size
	  state=S_DATA
	end
      when S_DATA
	data_raw=c
	checksum = cksum(data_raw, checksum)
	state=S_CHECKSUM
	data_to_read=1
      when S_CHECKSUM
	ck=c.ord
	if checksum != ck
	  puts "Error in checksum"
	  state=S_ERROR
	else
	  state=S_END
	end
      end
    end
    @fd.flush_input
    if state == S_END
      ok=true
    else
    end
    [ok,cmd,data_raw]
  end

  def write cmd
    @fd.syswrite cmd
  end

  def gets
    @fd.gets
  end

  def send_data cmd,data
    dsize = data.size
    sdata = "#{dsize.chr}#{cmd.chr}#{data}"
    ck =  cksum(sdata)
    mwdata = "#{HDR}#{sdata}#{ck.chr}"
    @fd.syswrite mwdata
  end

  def do_command wanted,data
    buf=nil
    loop do
      send_data wanted,data
      ok,cmd,buf=read_data
      break if cmd == wanted
      puts "retry #{cmd}"
    end
    buf
  end

  def initialize dev=DEV,baud=115200
    puts "dev #{dev} #{baud}"
    @fd = SerialPort.new(dev,baud)
    @fd.flow_control = SerialPort::NONE
    @fd.read 1
    @fd.read_timeout=100
  end

  def readloop
    loop do
      s = @fd.gets
      break if s.nil? or s.match(/^#\s*$/)
      yield s if block_given?
    end
  end
end

Encoding.default_external = Encoding::BINARY

dev=MSP::DEV
rate=115200
profiles=nil
tyaw=false
sfile=nil
ofile="cf_dump.txt"
resave=nil

prarry = [0]

ARGV.options do |opt|
  opt.banner = "cf_cli"
  opt.banner << "\nUsage: #{File.basename $0} [options] file"
  opt.on('-d',"--device DEV") {|o| dev=o}
  opt.on('-b',"--baudrate RATE", Integer) {|o| rate=o}
  opt.on('-p',"--profiles P[-Q]") {|o| profiles=o}
  opt.on('-o',"--output-file FILE") {|o| ofile=o}
  opt.on('-f','--force-tri-rev-yaw') {tyaw=true}
  opt.on('-r','--resave') {resave = true}
  opt.on('-?', "--help", "Show this message") {puts opt; exit}
  begin
    opt.parse!
  rescue
    puts opt ; exit
  end
end

def save_settings m, prarry, tyaw, ofile, mute=false
  prarry.each do |p|
    fn = ofile
    if prarry.size > 1
      d = File.dirname(sfile)
      e = File.extname(sfile)
      b = File.basename(a,e)
      e = "#{b}_p#{p}#{e}"
      fn = File.join(d,e)
    end
    File.open(fn,'w') do |f|
      f.puts "# mwptools / cf_cli dump #{Time.now.strftime("%FT%T%z")}"
      m.write "profile #{p}\n"
      m.readloop
      m.write "dump\n"
      m.readloop do|s|
	case s
	when /^Rebooting/,/^exit/,/^dump/,/^Entering/
	when /^Cleanflight/
	  f.puts "# #{s}"
	else
	  f.puts s
	end
	puts s unless mute
      end
      if tyaw
	f.puts "## rev-tri-yaw"
      end
    end
  end
end

sfile = ARGV[0]

if profiles
  prarry = profiles.split('-')
end

m = MSP.new dev,rate

buf = m.do_command(MSP::IDENT,'')
a=buf.unpack('CCCL')
servos=nil
if a[1] == 1
  buf = m.do_command(MSP::SERVO_CONF,'')
  servos = buf.unpack("SSScSSScSSScSSScSSScSSScSSScSSSc")
  if (servos[23] & 1) == 1
    tyaw = true
  end
end

m.write "#"
m.readloop {|s| puts s }
save_settings m, prarry, tyaw, ofile

if sfile.nil?
  m.write "exit\n"
  m.readloop {|s| puts s}
else
  m.write "defaults\n"
  m.readloop {|s| puts s}
  sleep 2
  buf = m.do_command(MSP::IDENT,'')
  m.write "#"
  m.readloop
    puts "send file"
  File.open(sfile) do |f|
    f.each do |l|
      case l
      when /^## rev-tri-yaw/
	tyaw = true
      when /^#/,/^\s*$/
	# skip
      else
	m.write l
	m.readloop {|s| puts s}
      end
    end
  end

  m.write "save\n"
  m.readloop {|s| puts s}
  if tyaw || resave
    sleep 2
    buf = m.do_command(MSP::IDENT,'')
    a=buf.unpack('CCCL')
    if tyaw and a[1] == 1
      buf = m.do_command(MSP::SERVO_CONF,'')
      servos = buf.unpack("SSScSSScSSScSSScSSScSSScSSScSSSc")
      servos[23] |= 1
      str = servos.pack("SSScSSScSSScSSScSSScSSScSSScSSSc")
      buf = m.do_command(MSP::SET_SERVO_CONF,str)
      buf = m.do_command(MSP::EEPROM_WRITE,'')
    end
    m.write "#"
    m.readloop
    fn = "#{ofile}.#{Time.now.strftime("%Y%m%d_%H%M%S")}"
    save_settings m, prarry, tyaw, fn, true
    m.write "exit\n"
    m.readloop
    puts "Updated settings saved to #{fn}"
  end
end
