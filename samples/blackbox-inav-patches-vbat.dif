--- src/blackbox_decode.c.orig	2018-07-13 18:34:14.097825354 +0100
+++ src/blackbox_decode.c	2018-07-13 22:34:51.315930082 +0100
@@ -111,6 +111,8 @@
 
 static seriesStats_t looptimeStats;
 
+static uint8_t use_new_vbat;
+
 #define ADJUSTMENT_FUNCTION_COUNT 21
 static char *INFLIGHT_ADJUSTMENT_FUNCTIONS[ADJUSTMENT_FUNCTION_COUNT] = {
         "NONE",
@@ -178,13 +180,19 @@
     switch (unit) {
         case UNIT_VOLTS:
             if (fieldIndex == log->mainFieldIndexes.vbatLatest) {
-                fprintf(file, "%.3f", flightLogVbatADCToMillivolts(log, (uint16_t)fieldValue) / 1000.0);
+                if(use_new_vbat)
+                    fprintf(file, "%.3f", (uint16_t)fieldValue / 100.0);
+                else
+                    fprintf(file, "%.3f", flightLogVbatADCToMillivolts(log, (uint16_t)fieldValue) / 1000.0);
                 return true;
             }
         break;
         case UNIT_MILLIVOLTS:
             if (fieldIndex == log->mainFieldIndexes.vbatLatest) {
-                fprintf(file, "%u", flightLogVbatADCToMillivolts(log, (uint16_t)fieldValue));
+                if(use_new_vbat)
+                    fprintf(file, "%u", (uint16_t)fieldValue * 10);
+                else
+                    fprintf(file, "%u", flightLogVbatADCToMillivolts(log, (uint16_t)fieldValue));
                 return true;
             }
         break;
@@ -826,7 +834,7 @@
         memset(mainFieldUnit, 0, sizeof(mainFieldUnit));
         memset(gpsGFieldUnit, 0, sizeof(gpsGFieldUnit));
         memset(slowFieldUnit, 0, sizeof(slowFieldUnit));
-    
+
         if (log->mainFieldIndexes.vbatLatest > -1) {
             mainFieldUnit[log->mainFieldIndexes.vbatLatest] = options.unitVbat;
         }
@@ -1388,6 +1396,66 @@
     }
 }
 
+#define FWVLEN (sizeof("H Firmware revision:INAV ")-1)
+#define FWDATELEN (sizeof("H Firmware date:")-1)
+
+static void read_meta(const char *fname)
+{
+    FILE *fp = fopen(fname,"r");
+    if(fp != NULL)
+    {
+        char buf[4096];
+
+        while (fgets(buf, sizeof(buf), fp) != NULL)
+        {
+            if(buf[0] != 'H')
+                break;
+
+            if(strncmp(buf, "H Firmware revision:INAV ", FWVLEN) == 0)
+            {
+                uint8_t major=0,minor=0,micro=0;
+                char *ptr = buf+FWVLEN;
+
+                major = strtol(ptr, &ptr, 10);
+                if (ptr)
+                    minor = strtol(ptr, &ptr, 10);
+                if(ptr)
+                    micro = strtol(ptr, NULL, 10);
+
+                if(major  < 2) // Old vbat code
+                    break;
+
+                use_new_vbat = 1;
+
+                if(major > 2) // Must be new vbat code
+                    break;
+
+                    // 2.x.x, if 2.0.0 need to check date later ...
+                if (minor != 0 || micro != 0)
+                    break;
+            }
+                /* We only get here for 2.0.0 and need to check the date
+                 * and possibly revert the need to use later vbat code */
+            if(strncmp(buf, "H Firmware date:", FWDATELEN) == 0)
+            {
+                char *dstr = buf+FWDATELEN; // mmm dd yyyy WTF ...
+                int day = atoi(dstr+4);
+                int yr = atoi(dstr+7);
+                if (yr == 2018)
+                {
+                    if(strncmp(dstr,"Apr", 3) == 0 ||
+                       strncmp(dstr,"May", 3) == 0 ||
+                       strncmp(dstr,"Jun", 3) == 0 ||
+                       (strncmp(dstr,"Jul", 3) == 0 && day < 7))
+                        use_new_vbat = 0;
+                }
+            }
+        }
+        fclose(fp);
+    }
+}
+
+
 int main(int argc, char **argv)
 {
     flightLog_t *log;
@@ -1411,6 +1479,8 @@
     for (int i = optind; i < argc; i++) {
         const char *filename = argv[i];
 
+        read_meta(filename);
+
         fd = open(filename, O_RDONLY);
         if (fd < 0) {
             fprintf(stderr, "Failed to open log file '%s': %s\n\n", filename, strerror(errno));
